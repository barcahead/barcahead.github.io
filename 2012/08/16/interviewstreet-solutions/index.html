<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> InterviewStreet solutions · Ailurophile</title><meta name="description" content="InterviewStreet solutions - barcahead"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://barcahead.info/atom.xml" title="Ailurophile"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/barcahead" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">InterviewStreet solutions</h1><div class="post-info">Aug 16, 2012</div><div class="post-content"><h4 id="Kingdom-Connectivity"><a href="#Kingdom-Connectivity" class="headerlink" title="Kingdom Connectivity"></a>Kingdom Connectivity</h4><p>大意就是计算一个图中从A到B一共有多少条路径，如果包含环就返回infinit。思路是首先找出从A到B所有可能经过的点，这里可以从A和B分别dfs，找出可达点的交集。然后再对这些点做拓扑排序，这个过程中记录到每个点的路径数。有环的情况也可以在时候排除掉。</p>
<h4 id="String-Reduction"><a href="#String-Reduction" class="headerlink" title="String Reduction"></a>String Reduction</h4><p>一个字符串只有a，b，c三种字符，相邻的不同字符可以转变成另一个字符，问最后字符串最短的长度。这题是规律题，数学题证明一直不是我的强项，所以就大概领会下吧。首先要发现如果只有一种字符，字符串的长度就无法缩小了。其余情况最后字符串长度只能是1或为2。长度为2的情况最后字符个数只能为1，1，1，逆着推回去，可以发现三种字符串个数同时为偶数或者奇数。长度为1的最后状态是1，1，0，同理往回推。</p>
<h4 id="Binomial-Coefficients"><a href="#Binomial-Coefficients" class="headerlink" title="Binomial Coefficients"></a>Binomial Coefficients</h4><p><code>log_p(C)</code>表示排列组合C中p的个数，<code>b_p(n)</code>表示n以p为base表示时每一位数字之和,则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">log_p(C) = log_p(n!) - log_p(k!) - log_p((n-k))</div><div class="line">log_p(n!) = sum(floor(n/p^i)) = (n - b_p(n)) / (p -1)</div><div class="line">log_p(C) = (b_p(k) + b_p(n-k) - b_p(n)) / (p-1)</div></pre></td></tr></table></figure></p>
<p>若p base下k加上n-k没有进位，则<code>b_p(k)+b_p(n-k)-b_p(n)</code>等于0，则C中不存在p。若有进位，低位减p，高位加1，C中至少存在一个p。<br>没有进位的k满足每一位小于等于n中对应位的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = a0 + a1*p + ... + ai*p^i</div><div class="line">ans = n + 1 - mul(ai+1)</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h4 id="Meeting-Point"><a href="#Meeting-Point" class="headerlink" title="Meeting Point"></a>Meeting Point</h4><p>可移动到相邻的八个格子中，即求Chebyshev距离。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d = max( |x1-x2|, |y1-y2| )</div><div class="line">  = ( |x1+y1-x2-y2| + |x1-y1-(x2+y2)| ) / 2</div></pre></td></tr></table></figure></p>
<p>所以<code>point(x, y)</code>间的Chebyshev距离可以转化为求<code>point(x+y, x-y)</code>间的Manhattan距离。Manhattan距离比较好求，可以对点集在x轴和y轴分别排序求出，然后枚举每个点X轴和Y轴距离之和，求出最小值即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ans = min(lx[xi]+rx[xi]+ly[yi]+ry[yi])</div></pre></td></tr></table></figure></p>
<h4 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h4><p>需要隔离K个machine，必须删除K-1条边。把边按时间从大到小排序，依次选择，用并查集维护连通子图和子图中的machine。若边加入后，存在两个machine连通，则不选择此条边。</p>
<h4 id="Problem-Solving"><a href="#Problem-Solving" class="headerlink" title="Problem Solving"></a>Problem Solving</h4><p>即求有向无环图的最小路径覆盖数 = 定点数 - 扩点后二分图最大匹配数。扩点方法为二分图左边右边各有所有一个点集V,V’，若有从点i到点j的边，则添加从i到j’的边。</p>
<p>代码略, 更新于2012.09.18</p>
</div></article></div></section><footer><div class="paginator"><a href="/2017/01/05/parameterized-type/" class="prev">PREV</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'barcahead';
var disqus_identifier = '2012/08/16/interviewstreet-solutions/';
var disqus_title = 'InterviewStreet solutions';
var disqus_url = 'http://barcahead.info/2012/08/16/interviewstreet-solutions/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//barcahead.disqus.com/count.js" async></script><div class="copyright"><p>© 2016 - 2017 <a href="http://barcahead.info">barcahead</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-33281599-1",'auto');ga('send','pageview');</script></body></html>