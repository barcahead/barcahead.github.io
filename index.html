<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Ailurophile</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://barcahead.info/atom.xml" title="Ailurophile"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/barcahead" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/01/05/parameterized-type/" class="post-title-link">Parameterized type</a></h2><div class="post-info">Jan 5, 2017</div><div class="post-content"><h4 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h4><p>scala支持<code>parameterized types</code>,其实和java中的<code>generic</code>是一个含义，java用<code>&lt;T&gt;</code>,scala用<code>[T]</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> strings: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>)</div><div class="line"><span class="keyword">val</span> ints: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line"><span class="keyword">val</span> somes: <span class="type">List</span>[<span class="type">Some</span>[<span class="type">Int</span>]] = <span class="type">List</span>(<span class="type">Some</span>(<span class="number">1</span>), <span class="type">Some</span>(<span class="number">2</span>), <span class="type">None</span>)</div></pre></td></tr></table></figure>
<h4 id="Variance"><a href="#Variance" class="headerlink" title="Variance"></a>Variance</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>[+<span class="type">A</span>] </span>&#123;...&#125;   		<span class="comment">//covariant</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>[-<span class="type">A</span>] </span>&#123;...&#125;   		<span class="comment">//contravariant</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>[<span class="type">A</span>] </span>&#123;...&#125;    		<span class="comment">//invariant</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>[-<span class="type">A</span>, <span class="type">B</span>, +<span class="type">C</span>] </span>&#123;...&#125;	<span class="comment">//mixed</span></div></pre></td></tr></table></figure>
<p><code>+</code>表示如果<code>A</code>是<code>B</code>的子类，则<code>X[A]</code>是<code>X[B]</code>的子类</p>
<p><code>-</code>表示如果<code>A</code>是<code>B</code>的子类，则<code>X[B]</code>是<code>X[A]</code>的子类</p>
<p>如果既不是<code>+</code>也不是<code>-</code>，则<code>X[A]</code>和<code>X[B]</code>没有关系</p>
<h5 id="Covariant"><a href="#Covariant" class="headerlink" title="Covariant"></a>Covariant</h5><p><code>String</code>是<code>AnyRef</code>的子类，<code>List[String]</code>也是<code>List[AnyRef]</code>的子类。<code>List</code>在scala中的声明如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>[+<span class="type">A</span>]</span></div></pre></td></tr></table></figure>
<h5 id="Cotravariant"><a href="#Cotravariant" class="headerlink" title="Cotravariant"></a>Cotravariant</h5><p>最简单的contravariant是traits <code>FuntionN</code>, <code>N</code>从0到22，代表函数参数的数量，比如<code>scala.Function2</code>。scala使用这些traits来实现匿名函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) map (i =&gt; i + <span class="number">3</span>) <span class="comment">// List(4, 5, 6, 7)</span></div></pre></td></tr></table></figure>
<p>函数表达式<code>i =&gt; i + 3</code>其实是<code>scala.Funtion1</code>的语法糖</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> f: <span class="type">Int</span> =&gt; <span class="type">Int</span> = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(i: <span class="type">Int</span>): <span class="type">Int</span> = i + <span class="number">3</span></div><div class="line">&#125;</div><div class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) map f</div></pre></td></tr></table></figure>
<p>由于Java 8之前的jvm不支持匿名函数，所以scala采用匿名类的方式来实现匿名函数，Java 8中添加了lambdas支持</p>
<p>traits <code>scala.Function1</code>的声明为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[-<span class="type">T</span>, +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span></span></div></pre></td></tr></table></figure>
<p>第一个类型参数为函数参数，是contravariant，第二个类型参数为函数返回值，是covariant。对于其他<code>FunctionN</code> ，函数参数都是contravariant</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSuper</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">msuper</span></span>() = println(<span class="string">"CSuper"</span>) &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">CSuper</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">m</span></span>() = println(<span class="string">"C"</span>) &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSub</span> <span class="keyword">extends</span> <span class="title">C</span> </span>&#123; <span class="function"><span class="keyword">def</span> <span class="title">msub</span></span>() = println(<span class="string">"CSub"</span>) &#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f: <span class="type">C</span> =&gt; <span class="type">C</span> 	= 	(c: <span class="type">C</span>)		=&gt; <span class="keyword">new</span> <span class="type">C</span></div><div class="line">    f:			=	(c: <span class="type">CSuper</span>)	=&gt; <span class="keyword">new</span> <span class="type">CSub</span></div><div class="line">    f:			=	(c: <span class="type">CSuper</span>) =&gt; <span class="keyword">new</span> <span class="type">C</span></div><div class="line">    f: 			=	(c: <span class="type">C</span>)		=&gt; <span class="keyword">new</span> <span class="type">CSub</span></div><div class="line">    f:			=	(c: <span class="type">Csub</span>)	=&gt; <span class="keyword">new</span> <span class="type">CSuper</span>		<span class="comment">//编译错误！</span></div></pre></td></tr></table></figure>
<p>为什么?</p></div><a href="/2017/01/05/parameterized-type/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/08/16/interviewstreet-solutions/" class="post-title-link">InterviewStreet solutions</a></h2><div class="post-info">Aug 16, 2012</div><div class="post-content"><h4 id="Kingdom-Connectivity"><a href="#Kingdom-Connectivity" class="headerlink" title="Kingdom Connectivity"></a>Kingdom Connectivity</h4><p>大意就是计算一个图中从A到B一共有多少条路径，如果包含环就返回infinit。思路是首先找出从A到B所有可能经过的点，这里可以从A和B分别dfs，找出可达点的交集。然后再对这些点做拓扑排序，这个过程中记录到每个点的路径数。有环的情况也可以在时候排除掉。</p>
<h4 id="String-Reduction"><a href="#String-Reduction" class="headerlink" title="String Reduction"></a>String Reduction</h4><p>一个字符串只有a，b，c三种字符，相邻的不同字符可以转变成另一个字符，问最后字符串最短的长度。这题是规律题，数学题证明一直不是我的强项，所以就大概领会下吧。首先要发现如果只有一种字符，字符串的长度就无法缩小了。其余情况最后字符串长度只能是1或为2。长度为2的情况最后字符个数只能为1，1，1，逆着推回去，可以发现三种字符串个数同时为偶数或者奇数。长度为1的最后状态是1，1，0，同理往回推。</p>
<h4 id="Binomial-Coefficients"><a href="#Binomial-Coefficients" class="headerlink" title="Binomial Coefficients"></a>Binomial Coefficients</h4><p><code>log_p(C)</code>表示排列组合C中p的个数，<code>b_p(n)</code>表示n以p为base表示时每一位数字之和,则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">log_p(C) = log_p(n!) - log_p(k!) - log_p((n-k))</div><div class="line">log_p(n!) = sum(floor(n/p^i)) = (n - b_p(n)) / (p -1)</div><div class="line">log_p(C) = (b_p(k) + b_p(n-k) - b_p(n)) / (p-1)</div></pre></td></tr></table></figure></p>
<p>若p base下k加上n-k没有进位，则<code>b_p(k)+b_p(n-k)-b_p(n)</code>等于0，则C中不存在p。若有进位，低位减p，高位加1，C中至少存在一个p。<br>没有进位的k满足每一位小于等于n中对应位的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">n = a0 + a1*p + ... + ai*p^i</div><div class="line">ans = n + 1 - mul(ai+1)</div></pre></td></tr></table></figure></p></div><a href="/2012/08/16/interviewstreet-solutions/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"></div><div class="copyright"><p>© 2016 - 2017 <a href="http://barcahead.info">barcahead</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-33281599-1",'auto');ga('send','pageview');</script></body></html>